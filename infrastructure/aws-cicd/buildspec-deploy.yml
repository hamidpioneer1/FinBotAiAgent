version: 0.2

phases:
  pre_build:
    commands:
      - echo "Starting EC2 deployment..."
      - echo "EC2 Instance ID: $EC2_INSTANCE_ID"
      - echo "Deployment Port: $DEPLOYMENT_PORT"
      - echo "Deployment Folder: $DEPLOYMENT_FOLDER"
      - echo "Image Repository: $IMAGE_REPO_NAME"
      
      # Install AWS CLI v2 and SSM agent
      - yum update -y
      - yum install -y aws-cli
      - yum install -y amazon-ssm-agent
      
      # Get EC2 instance information
      - aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region $AWS_DEFAULT_REGION --query 'Reservations[0].Instances[0].{PublicIp:PublicIpAddress,State:State.Name}' --output table
      
      # Get instance public IP
      - INSTANCE_IP=$(aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region $AWS_DEFAULT_REGION --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
      - echo "Instance IP: $INSTANCE_IP"
      
      # Check if instance is running
      - INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $EC2_INSTANCE_ID --region $AWS_DEFAULT_REGION --query 'Reservations[0].Instances[0].State.Name' --output text)
      - echo "Instance State: $INSTANCE_STATE"
      
      - if [ "$INSTANCE_STATE" != "running" ]; then
          echo "ERROR: Instance is not running. Current state: $INSTANCE_STATE"
          exit 1
        fi

  build:
    commands:
      - echo "Preparing deployment package..."
      
      # Create deployment script
      - cat > deploy-to-ec2.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üöÄ Starting CodePipeline deployment on EC2..."
        
        # Create deployment directory
        sudo mkdir -p $DEPLOYMENT_FOLDER
        cd $DEPLOYMENT_FOLDER
        
        # Stop existing container if running
        echo "üõë Stopping existing container..."
        sudo docker stop finbotaiagent-codepipeline || true
        sudo docker rm finbotaiagent-codepipeline || true
        
        # Login to ECR
        echo "üîê Logging in to ECR..."
        aws ecr get-login-password --region $AWS_DEFAULT_REGION | sudo docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
        
        # Pull latest image
        echo "üì• Pulling latest image..."
        sudo docker pull $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:latest
        
        # Create docker-compose file for CodePipeline deployment
        echo "üìù Creating docker-compose configuration..."
        sudo tee docker-compose-codepipeline.yml << 'DOCKER_COMPOSE_EOF'
        version: '3.8'
        services:
          finbotaiagent-codepipeline:
            image: $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:latest
            container_name: finbotaiagent-codepipeline
            ports:
              - "$DEPLOYMENT_PORT:8080"
            environment:
              - ASPNETCORE_ENVIRONMENT=Production
              - ASPNETCORE_URLS=http://+:8080
            env_file:
              - .env.codepipeline
            restart: unless-stopped
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8080/weatherforecast"]
              interval: 30s
              timeout: 10s
              retries: 3
              start_period: 40s
        DOCKER_COMPOSE_EOF
        
        # Create environment file for CodePipeline deployment
        echo "üîß Creating environment configuration..."
        sudo tee .env.codepipeline << 'ENV_EOF'
        # Database configuration (same as GitHub Actions deployment)
        DB_HOST=localhost
        DB_USERNAME=postgres
        DB_PASSWORD=your_db_password_here
        DB_NAME=finbotdb
        ENV_EOF
        
        # Update environment file with actual values from SSM
        echo "üîê Updating environment with SSM parameters..."
        DB_HOST_VALUE=$(aws ssm get-parameter --name "/$PROJECT_NAME/db/host" --region $AWS_DEFAULT_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo "localhost")
        DB_USERNAME_VALUE=$(aws ssm get-parameter --name "/$PROJECT_NAME/db/username" --region $AWS_DEFAULT_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo "postgres")
        DB_NAME_VALUE=$(aws ssm get-parameter --name "/$PROJECT_NAME/db/name" --region $AWS_DEFAULT_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo "finbotdb")
        DB_PASSWORD_VALUE=$(aws secretsmanager get-secret-value --secret-id "$PROJECT_NAME/db/password" --region $AWS_DEFAULT_REGION --query 'SecretString' --output text 2>/dev/null || echo "your_db_password_here")
        
        sudo sed -i "s/DB_HOST=.*/DB_HOST=$DB_HOST_VALUE/" .env.codepipeline
        sudo sed -i "s/DB_USERNAME=.*/DB_USERNAME=$DB_USERNAME_VALUE/" .env.codepipeline
        sudo sed -i "s/DB_PASSWORD=.*/DB_PASSWORD=$DB_PASSWORD_VALUE/" .env.codepipeline
        sudo sed -i "s/DB_NAME=.*/DB_NAME=$DB_NAME_VALUE/" .env.codepipeline
        
        # Start the container
        echo "üöÄ Starting new container..."
        sudo docker-compose -f docker-compose-codepipeline.yml up -d
        
        # Wait for container to be healthy
        echo "‚è≥ Waiting for container to be healthy..."
        for i in {1..30}; do
          if sudo docker ps --filter "name=finbotaiagent-codepipeline" --filter "health=healthy" | grep -q finbotaiagent-codepipeline; then
            echo "‚úÖ Container is healthy!"
            break
          fi
          echo "Waiting... ($i/30)"
          sleep 10
        done
        
        # Show container status
        echo "üìä Container status:"
        sudo docker ps --filter "name=finbotaiagent-codepipeline"
        
        # Test the application
        echo "üß™ Testing application..."
        sleep 5
        if curl -f http://localhost:$DEPLOYMENT_PORT/weatherforecast; then
          echo "‚úÖ Application is responding correctly!"
        else
          echo "‚ùå Application health check failed"
          sudo docker logs finbotaiagent-codepipeline
          exit 1
        fi
        
        echo "üéâ CodePipeline deployment completed successfully!"
        echo "üåê Application available at: http://$INSTANCE_IP:$DEPLOYMENT_PORT"
        echo "üìã GitHub Actions deployment: http://$INSTANCE_IP:8080"
        echo "üìã CodePipeline deployment: http://$INSTANCE_IP:$DEPLOYMENT_PORT"
        EOF
      
      - chmod +x deploy-to-ec2.sh

  post_build:
    commands:
      - echo "Deploying to EC2 instance..."
      
      # Send command to EC2 instance via SSM
      - echo "üì§ Sending deployment command to EC2..."
      - COMMAND_ID=$(aws ssm send-command \
          --instance-ids $EC2_INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["bash /tmp/deploy-to-ec2.sh"]' \
          --region $AWS_DEFAULT_REGION \
          --query 'Command.CommandId' \
          --output text)
      
      - echo "Command ID: $COMMAND_ID"
      
      # Wait for command to complete
      - echo "‚è≥ Waiting for deployment to complete..."
      - aws ssm wait command-executed \
          --command-id $COMMAND_ID \
          --instance-id $EC2_INSTANCE_ID \
          --region $AWS_DEFAULT_REGION
      
      # Get command output
      - echo "üìã Deployment output:"
      - aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id $EC2_INSTANCE_ID \
          --region $AWS_DEFAULT_REGION \
          --query 'StandardOutputContent' \
          --output text
      
      # Check for errors
      - EXIT_CODE=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id $EC2_INSTANCE_ID \
          --region $AWS_DEFAULT_REGION \
          --query 'ResponseCode' \
          --output text)
      
      - if [ "$EXIT_CODE" != "0" ]; then
          echo "‚ùå Deployment failed with exit code: $EXIT_CODE"
          echo "Error output:"
          aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id $EC2_INSTANCE_ID \
              --region $AWS_DEFAULT_REGION \
              --query 'StandardErrorContent' \
              --output text
          exit 1
        fi
      
      - echo "‚úÖ EC2 deployment completed successfully!"

artifacts:
  files:
    - deploy-to-ec2.sh
  name: finbotaiagent-ec2-deployment-$(date +%Y-%m-%d)
